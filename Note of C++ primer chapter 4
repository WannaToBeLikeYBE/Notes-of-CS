第四章 表达式
1.基础概念：左值：当一个对象被用作左值，用的是它的身份（在内存中的位置）。
           右值：当一个对象被用作右值，用的是它的值（内容）。
注：指针是右值。
    如果表达式的求职结果是左值，decltype作用于该表达式得到一个引用类型。
           求值顺序：大多数情况下不会明确指明求值顺序，而如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为。
                    除了以下四种：&& || ?: ,
2.算数运算符：+-（正负）    */%   +-
3.逻辑和关系运算符：!    <,<=,>,>=   ==,!=   &&    ||
4.赋值运算符：赋值运算符满足右结合律，优先级较低。
5.递增和递减运算符：++ -- 注意前置和后置的区别。
                  建议：多用前置减少浪费，后置创造了一个副本。
                        当让例如std::cout<<i++;可以让你的代码更简洁。
6.成员访问运算符：->

7.条件运算符：?:
条件运算符将简单的if-else逻辑嵌入到单个表达式中，形如  cond?expr1:expr2;
首先求cond值，若真则expr1，否则expr2。
允许在条件运算符的内部嵌套另一个条件运算符。
条件运算符的有限度非常低。
eg.std::cout<<((grade>90)?“优秀”
                                :(grade>60)?"良好"：“合格”))；
                                
8.位运算符:-求反 << >> & ^ | 作用于整数类型
  <<左移在右侧插入值为0的二进制位；若对象无符号，>>右移插入0，否则视原符号而定。
  
9.sizeof运算符：右结合律 sizeof(type)或sizeof expr
               注：对string使用返回固定大小。

10.逗号运算符：先对左侧求值再对右侧求值

11.类型转换：隐式转换
显示转换：旧式：type(expr)或（type）expr

新式：（1）static_cast：任何具有明确定义的类型转换，只要不包括底层const，就可以使用static_cast。
                       eg.double slope = static_cast<double>(j);
                       我们可以用static_cast找回存在在void*指针中的值。
                       eg.void* p = &d;
                          double *dp = static_cast<double*>(p);
                          
      （2）const_cast：const_cast只能改变运算对象的底层const。
      对于将常量对象转换为非常量对象，我们一般称其为“去掉const性质”。然而如果底层const对象是一个常量，执行写操作时会产生未定义的后果
      也就是说，C++语言没有明确规定如何处理这一行为，由编译器决定，因此要尽量避免未定义行为。
      eg.const int a = 10;
         const int *b = &a;
         int *c = const_cast<int*> b;
         &c = 20;  //error:未定义行为
         std::cout<<a<<' '<<&c;  //VS2015：10 20
      const_cast有很多使用情景，例如调用一个形参不是const的函数，而输入的实参是一个const，函数本身不修改参数。用const_cast去掉const性质，
      从而直接导入。
      （3）reinterpret_cast：为运算对象的位模式提供较低层次上的重新解释。
      
12.运算符优先级表：见书。
        
