第二章也是一些基础内容
常量算是半个重点吧

2.1 基本内置类型
tips
1.执行浮点数运算选择double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。
2.注意不要混用带符号类型和无符号类型，做这事因为带符号数会自动转换为无符号数。
3.浮点型字面值默认为double，十进制字面值默认带符号，而八进制（0开头）和十六进制（0x^0X)可能带符号也可能不带。
4.泛化的转义序列：其形式为\x后跟一个或多个十六进制数字，或者\后跟3个以内的八进制数字，其数字部分表示的是字符对应的数值。
5.可以通过前缀和后缀改变字面值的默认类型，详见书P37。

2.2变量
tips
1.对象与变量 对象的概念：具有某种数据类型的内存空间。
2.初始化不是赋值
3.列表初始化：用花括号来初始化变量
  eg.int unit_sold{1};
  当使用列表初始化的时候，如果初始值存在丢失信息的风险，则编译器将报错。
  eg.int a{3.14159260};
4.声明创建了名字，定义创造与名字关联的实体
  如果想声明变量并且不定义它，就在变量名前添加关键字extern并且不要显式定义它
  eg.extern int i;
5.名字的作用域：Cpp中大多数作用域以花括号分隔。函数体外的名字拥有全局定义域，其他则拥有块定义域。
  当新建同名局部变量时，在其作用域内会暂时覆盖全局变量
  eg.int a=0;
   int main()
   {
      int a =1;
      cout<<a<<endl;  //输出1
      cout<<::a<<endl; //输出0
   }
   因为全局定义域本身并没有名字，所以当作用域操作符左侧为空时，向全局定义域发出请求获取右侧对应全局变量。
   
2.3复合类型
      复合类型时基于其他类型定义的类型，其中的两种：引用和指针。
      （复合类型的类修饰符&和*本质上只是声明符的一部分，类似于变量名）
   a.引用
      引用本身不是一个对象，一旦定义了引用就无法再解绑。
      //The direct reason I introduced them in Cpp was to support operator overloading.
      eg.int a，&b=a; //b是a的引用
   b.指针
      空指针与void*指针：
        得到空指针最直接的办法就是用字面值nullptr来初始化指针，nullptr是一种特殊类型的字面值，它可以转化为任意的指针类型。
        void*是一种特殊的指针类型，可以存放任意对象的地址
      两者的区别：
        空指针指向内存0，即NULL，而void*有具体实际的指向地址。
        
2.4const限定符
   a.const概念
      1.const限定符限制了对于对象的修改，const对象必须初始化。
      2.默认情况下const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在变量定义引用前添加extern关键字。
   b.const的引用 没什么意思
        const的引用：把引用绑定到const对象上，称为对常量的引用。对const的引用可能引用一个非const对象。
        eg.const int &a=3.141592658;
        初始化常量引用时允许用任何表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。
        上述案例相当于
        eg.const int tmp=3.141592658;
           const int &a=tmp;
           在这种情况下，a绑定了一个临时量对象。
        conspect
            1.左值和右值的区别在于能否取得其内存地址。通常右值为临时量而左值可以获取内存地址。
            2.非常量引用的初始值必须为左值，常量引用无此要求。
   c.指针和const
      概念1（常量指针）：指针本身是一个对象，而常量指针是一个常量的指针对象，他是一个顶层const（top-level const）。
                  eg.int *const a=.......;
      概念2（指向常量的指针）：指向常量的指针是底层const(low-level const)，他是一个被const限定符限定的指针。
                  eg.const int *a=.......;
      
      常量指针本身是常量，他在初始化时绑定并且不可解绑，可以通过常量指针修改所指向的内存内容。
      而指向常量的指针在初始化时绑定一个对象，并且可以解绑改变绑定的对象。但因为被const限定符限定，不可以通过指针直接修改内存内容。
      本质上const限定符默认了初始值为常量，其功能为限定了通过const限定不可以通过对象对初始量进行修改，然而在实际情况下初始值不一定为常量。
   d.顶层const
      一般上顶层const可以表示任意的对象是常量，底层const则表明引用或指向的对象为常量。
   e.constexpr和常量表达式
      Cpp11新标准规定，允许将变量申明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
      声明为constexpr的变量一定是一个常量，而且必须由常量表达式初始化
      同时constexpr把它所定义的对象置为了顶层const。
      eg. const int *p=nullptr;    //p是一个指向整型常量的指针
          constexpr int *q=nullptr;    //q是一个常量指针
      constexpr指针既可以指向常量也可以指向非常量。
      
      
      
      
  
      
      
