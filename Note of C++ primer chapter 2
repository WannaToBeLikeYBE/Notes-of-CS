第二章也是一些基础内容
常量算是半个重点吧

2.1 基本内置类型
tips
1.执行浮点数运算选择double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。
2.注意不要混用带符号类型和无符号类型，做这事因为带符号数会自动转换为无符号数。
3.浮点型字面值默认为double，十进制字面值默认带符号，而八进制（0开头）和十六进制（0x^0X)可能带符号也可能不带。
4.泛化的转义序列：其形式为\x后跟一个或多个十六进制数字，或者\后跟3个以内的八进制数字，其数字部分表示的是字符对应的数值。
5.可以通过前缀和后缀改变字面值的默认类型，详见书P37。

2.2变量
tips
1.对象与变量 对象的概念：具有某种数据类型的内存空间。
2.初始化不是赋值
3.列表初始化：用花括号来初始化变量
  eg.int unit_sold{1};
  当使用列表初始化的时候，如果初始值存在丢失信息的风险，则编译器将报错。
  eg.int a{3.14159260};
4.声明创建了名字，定义创造与名字关联的实体
  如果想声明变量并且不定义它，就在变量名前添加关键字extern并且不要显式定义它
  eg.extern int i;
5.名字的作用域：Cpp中大多数作用域以花括号分隔。函数体外的名字拥有全局定义域，其他则拥有块定义域。
  当新建同名局部变量时，在其作用域内会暂时覆盖全局变量
  eg.int a=0;
   int main()
   {
      int a =1;
      cout<<a<<endl;  //输出1
      cout<<::a<<endl; //输出0
   }
   因为全局定义域本身并没有名字，所以当作用域操作符左侧为空时，向全局定义域发出请求获取右侧对应全局变量。
   
2.3复合类型
      复合类型时基于其他类型定义的类型，其中的两种：引用和指针。
      （复合类型的类修饰符&和*本质上只是声明符的一部分，类似于变量名）
   a.引用
      引用本身不是一个对象，一旦定义了引用就无法再解绑。
      //The direct reason I introduced them in Cpp was to support operator overloading.
      eg.int a，&b=a; //b是a的引用
   b.指针
      空指针与void*指针：
        得到空指针最直接的办法就是用字面值nullptr来初始化指针，nullptr是一种特殊类型的字面值，它可以转化为任意的指针类型。
        void*是一种特殊的指针类型，可以存放任意对象的地址
      两者的区别：
        空指针指向内存0，即NULL，而void*有具体实际的指向地址。
        
2.4const限定符
   a.const概念
      1.const限定符限制了对于对象的修改，const对象必须初始化。
      2.默认情况下const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在变量定义引用前添加extern关键字。
   b.const的引用 没什么意思
        const的引用：把引用绑定到const对象上，称为对常量的引用。对const的引用可能引用一个非const对象。
        eg.const int &a=3.141592658;
        初始化常量引用时允许用任何表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。
        上述案例相当于
        eg.const int tmp=3.141592658;
           const int &a=tmp;
           在这种情况下，a绑定了一个临时量对象。
        conspect
            1.左值和右值的区别在于能否取得其内存地址。通常右值为临时量而左值可以获取内存地址。
            2.非常量引用的初始值必须为左值，常量引用无此要求。
   c.指针和const
      概念1（常量指针）：指针本身是一个对象，而常量指针是一个常量的指针对象，他是一个顶层const（top-level const）。
                  eg.int *const a=.......;
      概念2（指向常量的指针）：指向常量的指针是底层const(low-level const)，他是一个被const限定符限定的指针。
                  eg.const int *a=.......;
      
      常量指针本身是常量，他在初始化时绑定并且不可解绑，可以通过常量指针修改所指向的内存内容。
      而指向常量的指针在初始化时绑定一个对象，并且可以解绑改变绑定的对象。但因为被const限定符限定，不可以通过指针直接修改内存内容。
      本质上const限定符默认了初始值为常量，其功能为限定了通过const限定不可以通过对象对初始量进行修改，然而在实际情况下初始值不一定为常量。
   d.顶层const
      一般上顶层const可以表示任意的对象是常量，底层const则表明引用或指向的对象为常量。
   e.constexpr和常量表达式
      Cpp11新标准规定，允许将变量申明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
      声明为constexpr的变量一定是一个常量，而且必须由常量表达式初始化
      同时constexpr把它所定义的对象置为了顶层const。
      eg. const int *p=nullptr;    //p是一个指向整型常量的指针
          constexpr int *q=nullptr;    //q是一个常量指针
      constexpr指针既可以指向常量也可以指向非常量。
      
 2.5处理类型
      1.类型别名
          a.typedef double wages;  //wages是double的同义词
          b.using wages = double;  //wages是double的同义词
      *注：eg.typedef char *pstring;
              const pstring ps;
              此时ps为常量指针。
              因为pstring为char*，const限定符此时修饰char*，所以ps为常量指针。
      2.auto类型说明符
            auto说明符能让编译器分析表达式所属的类型，auto定义的变量必须有初始值。
            eg.auto item = 1+1.0;    //item类型为double
            auto类型一般会忽略掉顶层const，保留底层const。
      3.decltype类型指示符
            decltype选择并返回操作数的数据类型，编译器分析表达式并得到他的类型（包括顶层const和引用），却不实际计算表达式的值。
            eg.decltype(f()) sum = x;  //sum的类型为f()返回类型，但不会实际调用函数f。
            **切记： 1.如果表达式的内容是解引用操作法a0。符。，则decltype将得到引用类型。
                        eg.int i=0,*p=&i;
                           decltype(*p) c;  //error：c的类型为引用，必须初始化。
                    2.decltype((variable))的结果永远是引用。
  
  2.6自定义数据结构
        预处理器概述：预处理器是在编译前执行的一段程序。
        例如：预处理功能#include相当于在编译前将头文件复制到当前代码中。
        以此为延伸，假如我在一个头文件a.h中定义了一个类，在另一个头文件b.h中需要用到这个类，那么我就需要在b.h中#include "a.h"。
        而在主程序的实际需求中，我需要同时用到a.h和b.h这两个头文件，那么我需要同时
        #include "a.h"
        #include "b.h"
        那么问题来了，第一次include相当于把a.h中对类的声明定义代码复制到主程序中，而第二次include又一次复制了一遍对于这个类的声明定义，
            由此将会造成重复定义的bug。
        为了避免这种情况，需要用到Cpp的一项预处理功能头文件保护符。
        头文件保护符依赖于预处理变量，这种变量无视Cpp的作用域规则，其有两种状态：已定义和未定义。
        我们用#define将一个名字定义为预处理变量，另外两个指令检测预处理变量的状态：#indef当变量已定义时为真，#ifndef当变量未定义时为真，
            一旦检查结果为真，则执行后续操作直到遇到#endif指令为止。
         现在，我们可以解决上面的问题了：
         
         对于头文件a.h，设置头文件保护符：
         #ifndef A
         #define A  //通常用大写字母表示预处理变量
         Struct a{};
         #endif
         当头文件a.h被include时，无论其处在何位置，先将检测预处理变量A是否定义，如果没有将定义预处理变量A，当后续被include时，#ifndef A
            将返回假，后续的include即复制操作将不会被执行，从而避免了被重定义。
         
         
         **头文件保护符很简单，只要习惯性地加上即可，没有必要太在乎你的程序到底需不需要。
      
      
  
      
      
